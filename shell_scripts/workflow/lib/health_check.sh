#!/bin/bash

################################################################################
# Workflow Health Check Library
# Version: 1.0.0
# Purpose: Verify workflow completion and capture failure points
# 
# Functions:
#   - verify_workflow_health()     - Check all 13 steps complete or capture failure
#   - validate_doc_placement()     - Enforce /docs directory for analysis reports
#   - enhanced_git_state_report()  - Detect coverage regeneration separately
################################################################################

# Verify all 13 steps completed successfully or identify where workflow stopped
# Returns: 0 if healthy (all steps passed), 1 if issues found
verify_workflow_health() {
    local health_status=0
    local total_steps=13  # Steps 0-12
    local completed_steps=0
    local failed_steps=0
    local skipped_steps=0
    local step_failures=()
    
    print_header "Workflow Health Check"
    log_to_workflow "INFO" "Starting workflow health verification"
    
    # Check each step status
    for step_num in {0..12}; do
        local step_key="step${step_num}"
        local status="${WORKFLOW_STATUS[$step_key]:-⏭️ NOT_EXECUTED}"
        
        case "$status" in
            *"✅"*|*"PASS"*)
                ((completed_steps++)) || true
                print_success "Step ${step_num}: Passed"
                ;;
            *"❌"*|*"FAIL"*)
                ((failed_steps++)) || true
                step_failures+=("Step ${step_num}: ${status}")
                print_error "Step ${step_num}: Failed - ${status}"
                health_status=1
                ;;
            *"⚠️"*|*"WARNING"*)
                ((completed_steps++)) || true
                print_warning "Step ${step_num}: Completed with warnings - ${status}"
                ;;
            *"⏭️"*|*"NOT_EXECUTED"*|*"SKIPPED"*)
                ((skipped_steps++)) || true
                print_info "Step ${step_num}: Skipped"
                ;;
            *)
                print_info "Step ${step_num}: ${status}"
                ((completed_steps++)) || true
                ;;
        esac
    done
    
    echo ""
    print_header "Health Check Results"
    print_info "Total Steps: ${total_steps}"
    print_info "Completed: ${completed_steps}"
    print_info "Failed: ${failed_steps}"
    print_info "Skipped: ${skipped_steps}"
    
    # Generate health report
    local health_report="${BACKLOG_RUN_DIR}/WORKFLOW_HEALTH_CHECK.md"
    cat > "$health_report" << EOF
# Workflow Health Check Report

**Workflow Run ID:** ${WORKFLOW_RUN_ID}
**Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
**Status:** $([ $health_status -eq 0 ] && echo "✅ HEALTHY" || echo "❌ ISSUES DETECTED")

---

## Summary

- **Total Steps:** ${total_steps}
- **Completed:** ${completed_steps}
- **Failed:** ${failed_steps}
- **Skipped:** ${skipped_steps}
- **Completion Rate:** $(awk "BEGIN {printf \"%.1f\", ($completed_steps/$total_steps)*100}")%

---

## Step-by-Step Status

EOF
    
    # Add detailed step status to report
    for step_num in {0..12}; do
        local step_key="step${step_num}"
        local status="${WORKFLOW_STATUS[$step_key]:-⏭️ NOT_EXECUTED}"
        echo "- **Step ${step_num}:** ${status}" >> "$health_report"
    done
    
    # Add failure details if any
    if [[ ${#step_failures[@]} -gt 0 ]]; then
        cat >> "$health_report" << EOF

---

## Failure Details

The following steps failed and require attention:

EOF
        for failure in "${step_failures[@]}"; do
            echo "- ${failure}" >> "$health_report"
        done
        
        cat >> "$health_report" << EOF

### Recommended Actions

1. Review the individual step reports in the backlog directory
2. Address the root cause of each failure
3. Re-run the workflow or specific failed steps using \`--steps\` flag
4. Monitor the health check report on subsequent runs

EOF
    fi
    
    cat >> "$health_report" << EOF

---

**Generated by:** Workflow Health Check v1.0.0
EOF
    
    print_success "Health check report saved: ${health_report}"
    log_to_workflow "INFO" "Workflow health check completed: ${completed_steps}/${total_steps} steps passed"
    
    return $health_status
}

# Validate that documentation files are placed in /docs directory
# Returns: 0 if validation passes, 1 if issues found
validate_doc_placement() {
    local validation_status=0
    local misplaced_docs=()
    
    print_header "Documentation Placement Validation"
    log_to_workflow "INFO" "Validating documentation placement"
    
    # Define patterns that should be in /docs
    local doc_patterns=(
        "TEST_EXECUTION_"
        "TEST_FAILURE_"
        "TEST_STRATEGY_"
        "TEST_RECOMMENDATIONS_"
        "COMPREHENSIVE_"
        "DEPENDENCY_ANALYSIS_"
        "CODE_QUALITY_"
        "DOCUMENTATION_UPDATE_"
        "WORKFLOW_"
    )
    
    # Search for misplaced documentation files
    print_info "Checking for misplaced documentation files..."
    
    for pattern in "${doc_patterns[@]}"; do
        # Search in src/ directory (should not contain these)
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                misplaced_docs+=("$file")
                print_warning "Misplaced: ${file} (should be in /docs)"
                validation_status=1
            fi
        done < <(find "${PROJECT_ROOT}/src" -type f -name "${pattern}*.md" 2>/dev/null)
        
        # Search in project root (should not contain these)
        while IFS= read -r file; do
            if [[ -f "$file" && "$(dirname "$file")" == "$PROJECT_ROOT" ]]; then
                misplaced_docs+=("$file")
                print_warning "Misplaced: ${file} (should be in /docs)"
                validation_status=1
            fi
        done < <(find "${PROJECT_ROOT}" -maxdepth 1 -type f -name "${pattern}*.md" 2>/dev/null)
    done
    
    # Generate validation report
    local validation_report="${BACKLOG_RUN_DIR}/DOCUMENTATION_PLACEMENT_VALIDATION.md"
    cat > "$validation_report" << EOF
# Documentation Placement Validation Report

**Workflow Run ID:** ${WORKFLOW_RUN_ID}
**Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
**Status:** $([ $validation_status -eq 0 ] && echo "✅ PASS" || echo "❌ FAIL")

---

## Validation Results

EOF
    
    if [[ ${#misplaced_docs[@]} -eq 0 ]]; then
        cat >> "$validation_report" << EOF
✅ **All documentation files are properly placed**

No analysis reports found outside of the \`/docs\` directory.

EOF
        print_success "All documentation files are properly placed"
    else
        cat >> "$validation_report" << EOF
❌ **Found ${#misplaced_docs[@]} misplaced documentation file(s)**

The following files should be moved to the appropriate subdirectory under \`/docs\`:

EOF
        for doc in "${misplaced_docs[@]}"; do
            local basename=$(basename "$doc")
            local suggested_location=""
            
            # Suggest appropriate location
            case "$basename" in
                TEST_*) suggested_location="/docs/testing-qa/" ;;
                COMPREHENSIVE_TESTING_*) suggested_location="/docs/testing-qa/" ;;
                DEPENDENCY_*) suggested_location="/docs/dependency-management/" ;;
                CODE_QUALITY_*) suggested_location="/docs/code-quality/" ;;
                DOCUMENTATION_UPDATE_*) suggested_location="/docs/documentation-updates/" ;;
                WORKFLOW_*) suggested_location="/docs/workflow-automation/" ;;
                COMPREHENSIVE_*) 
                    if [[ "$basename" =~ WORKFLOW ]]; then
                        suggested_location="/docs/workflow-automation/"
                    else
                        suggested_location="/docs/"
                    fi
                    ;;
                *) suggested_location="/docs/" ;;
            esac
            
            echo "- \`${doc}\` → \`${suggested_location}${basename}\`" >> "$validation_report"
        done
        
        cat >> "$validation_report" << EOF

### Recommended Actions

1. Move the misplaced files to their suggested locations
2. Update any references to these files in other documentation
3. Re-run this validation to confirm all files are properly placed
4. Update .gitignore if necessary to prevent future misplacements

EOF
        print_error "Found ${#misplaced_docs[@]} misplaced documentation file(s)"
    fi
    
    cat >> "$validation_report" << EOF

---

## Validation Rules

Documentation files matching these patterns should be in \`/docs\`:

EOF
    
    for pattern in "${doc_patterns[@]}"; do
        echo "- \`${pattern}*.md\`" >> "$validation_report"
    done
    
    cat >> "$validation_report" << EOF

---

**Generated by:** Documentation Placement Validator v1.0.0
EOF
    
    print_success "Documentation placement validation report saved: ${validation_report}"
    log_to_workflow "INFO" "Documentation placement validation completed: $([ $validation_status -eq 0 ] && echo "PASS" || echo "FAIL")"
    
    return $validation_status
}

# Enhanced git state reporting with separate coverage regeneration detection
# Returns: 0 always (informational only)
enhanced_git_state_report() {
    print_header "Enhanced Git State Analysis"
    log_to_workflow "INFO" "Generating enhanced git state report"
    
    # Get current git state from cache
    local branch=$(get_cached_git_branch)
    local status_output=$(get_cached_git_status)
    local diff_output=$(get_cached_git_diff)
    
    # Categorize changes
    local code_changes=()
    local test_changes=()
    local doc_changes=()
    local config_changes=()
    local coverage_changes=()
    local other_changes=()
    
    # Parse modified files
    while IFS= read -r line; do
        if [[ -z "$line" ]]; then continue; fi
        
        local file=$(echo "$line" | awk '{print $2}')
        
        case "$file" in
            src/coverage/*|*/coverage/*|*.lcov|*lcov.info)
                coverage_changes+=("$file")
                ;;
            *test*.js|*test*.mjs|*spec*.js|*spec*.mjs|*/__tests__/*)
                test_changes+=("$file")
                ;;
            *.md|*/docs/*|README*|CHANGELOG*)
                doc_changes+=("$file")
                ;;
            *.json|*.yaml|*.yml|.*.rc|*.config.js|*.config.mjs)
                config_changes+=("$file")
                ;;
            *.js|*.mjs|*.ts|*.tsx|*.jsx)
                code_changes+=("$file")
                ;;
            *)
                other_changes+=("$file")
                ;;
        esac
    done < <(echo "$status_output" | grep -E "^(M|A|D|R)" || true)
    
    # Generate enhanced report
    local git_report="${BACKLOG_RUN_DIR}/ENHANCED_GIT_STATE_REPORT.md"
    cat > "$git_report" << EOF
# Enhanced Git State Report

**Workflow Run ID:** ${WORKFLOW_RUN_ID}
**Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
**Branch:** ${branch}

---

## Change Summary

### Code Changes (${#code_changes[@]})
EOF
    
    if [[ ${#code_changes[@]} -gt 0 ]]; then
        for file in "${code_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
    else
        echo "*No code changes*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

### Test Changes (${#test_changes[@]})
EOF
    
    if [[ ${#test_changes[@]} -gt 0 ]]; then
        for file in "${test_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
    else
        echo "*No test changes*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

### Documentation Changes (${#doc_changes[@]})
EOF
    
    if [[ ${#doc_changes[@]} -gt 0 ]]; then
        for file in "${doc_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
    else
        echo "*No documentation changes*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

### Configuration Changes (${#config_changes[@]})
EOF
    
    if [[ ${#config_changes[@]} -gt 0 ]]; then
        for file in "${config_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
    else
        echo "*No configuration changes*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

### Coverage Report Changes (${#coverage_changes[@]})
EOF
    
    if [[ ${#coverage_changes[@]} -gt 0 ]]; then
        echo "" >> "$git_report"
        echo "⚠️ **Note:** Coverage reports are auto-generated and typically excluded from commits" >> "$git_report"
        echo "" >> "$git_report"
        for file in "${coverage_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
        
        cat >> "$git_report" << EOF

**Recommendation:** Review .gitignore to ensure coverage reports are properly excluded:
\`\`\`
coverage/
*.lcov
lcov.info
.nyc_output/
\`\`\`

EOF
    else
        echo "*No coverage report changes (as expected)*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

### Other Changes (${#other_changes[@]})
EOF
    
    if [[ ${#other_changes[@]} -gt 0 ]]; then
        for file in "${other_changes[@]}"; do
            echo "- \`${file}\`" >> "$git_report"
        done
    else
        echo "*No other changes*" >> "$git_report"
    fi
    
    cat >> "$git_report" << EOF

---

## Change Impact Analysis

- **Code changes:** $([ ${#code_changes[@]} -gt 0 ] && echo "Requires code review and testing" || echo "None")
- **Test changes:** $([ ${#test_changes[@]} -gt 0 ] && echo "Requires test execution verification" || echo "None")
- **Documentation changes:** $([ ${#doc_changes[@]} -gt 0 ] && echo "Requires documentation review" || echo "None")
- **Configuration changes:** $([ ${#config_changes[@]} -gt 0 ] && echo "Requires environment validation" || echo "None")
- **Coverage regeneration:** $([ ${#coverage_changes[@]} -gt 0 ] && echo "⚠️ Check .gitignore exclusions" || echo "✅ Not included")

---

**Generated by:** Enhanced Git State Reporter v1.0.0
EOF
    
    # Print summary
    echo ""
    print_info "Change Summary:"
    print_info "  Code: ${#code_changes[@]} files"
    print_info "  Tests: ${#test_changes[@]} files"
    print_info "  Docs: ${#doc_changes[@]} files"
    print_info "  Config: ${#config_changes[@]} files"
    print_info "  Coverage: ${#coverage_changes[@]} files"
    
    if [[ ${#coverage_changes[@]} -gt 0 ]]; then
        print_warning "Coverage reports detected - verify .gitignore exclusions"
    fi
    
    print_success "Enhanced git state report saved: ${git_report}"
    log_to_workflow "INFO" "Enhanced git state analysis completed"
    
    return 0
}

#!/bin/bash
set -euo pipefail

################################################################################
# Utility Functions Module
# Purpose: Common utility functions for workflow automation
# Part of: Tests & Documentation Workflow Automation v2.0.0
################################################################################

# ==============================================================================
# CONFIGURATION
# ==============================================================================

# Set AUTO_MODE default if not already set
AUTO_MODE=${AUTO_MODE:-false}

# ==============================================================================
# PRINT FUNCTIONS - Formatted console output with colors
# ==============================================================================

print_header() {
    local message="$1"
    echo -e "\n${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  ${message}${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}\n"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ ERROR: $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠️  WARNING: $1${NC}"
}

print_info() {
    echo -e "${CYAN}ℹ️  $1${NC}"
}

print_step() {
    local step_num="$1"
    local step_name="$2"
    echo -e "\n${MAGENTA}▶ Step ${step_num}: ${step_name}${NC}"
}

print_section() {
    local message="$1"
    echo -e "\n${CYAN}── ${message} ──${NC}"
}

# ==============================================================================
# BACKLOG AND SUMMARY HELPERS
# ==============================================================================

# Save issues found in a step to backlog
# Usage: save_step_issues <step_num> <step_name> <issues_content>
save_step_issues() {
    local step_num="$1"
    local step_name="$2"
    local issues_content="$3"
    
    if [[ "$DRY_RUN" == true ]]; then
        return 0
    fi
    
    # Create backlog directory structure if it doesn't exist
    mkdir -p "$BACKLOG_RUN_DIR"
    
    local step_file="${BACKLOG_RUN_DIR}/step${step_num}_${step_name// /_}.md"
    
    # Process content to convert \n to actual newlines
    local processed_content=$(echo -e "${issues_content}")
    
    # Create markdown report
    cat > "$step_file" << EOF
# Step ${step_num}: ${step_name}

**Workflow Run ID:** ${WORKFLOW_RUN_ID}
**Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
**Status:** Issues Found

---

## Issues and Findings

${processed_content}

---

**Generated by:** ${SCRIPT_NAME} v${SCRIPT_VERSION}
EOF
    
    print_info "Saved issues to: ${step_file}"
}

# Save step conclusion summary to summaries folder
# Usage: save_step_summary <step_num> <step_name> <summary_content> <status>
save_step_summary() {
    local step_num="$1"
    local step_name="$2"
    local summary_content="$3"
    local status="${4:-✅}"
    
    if [[ "$DRY_RUN" == true ]]; then
        return 0
    fi
    
    # Create summaries directory structure if it doesn't exist
    mkdir -p "$SUMMARIES_RUN_DIR"
    
    local summary_file="${SUMMARIES_RUN_DIR}/step${step_num}_${step_name// /_}_summary.md"
    
    # Create concise summary report
    cat > "$summary_file" << EOF
# Step ${step_num}: ${step_name} - Summary

**Status:** ${status}
**Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
**Workflow Run:** ${WORKFLOW_RUN_ID}

---

## Conclusion

${summary_content}

---

*Generated by ${SCRIPT_NAME} v${SCRIPT_VERSION}*
EOF
    
    print_info "Saved summary to: ${summary_file}"
}

# ==============================================================================
# USER INTERACTION
# ==============================================================================

# User confirmation prompt with auto-mode bypass
# Updated: Simplified to "Enter to continue or Ctrl+C to exit" pattern
confirm_action() {
    local prompt="$1"
    local default_answer="${2:-}"  # Optional: kept for compatibility but not used
    
    # Auto mode always returns true (yes)
    if [[ "$AUTO_MODE" == true ]]; then
        return 0
    fi
    
    # Play audio notification if available (v3.1.0)
    if type -t play_notification_sound > /dev/null 2>&1; then
        play_notification_sound "continue_prompt" 2>/dev/null || true
    fi
    
    # Display the prompt message
    echo -e "${CYAN}ℹ️  ${prompt}${NC}"
    
    # Simple continuation prompt - read from /dev/tty to handle input redirection
    read -r -p "$(echo -e "${YELLOW}Enter to continue or Ctrl+C to exit...${NC}")" < /dev/tty
    
    # Any response (including empty) continues
    return 0
}

# Collect AI-generated output from user (single-line or multi-line)
# Usage: collect_ai_output <prompt_message> <mode>
# Modes: "single" (single-line input), "multi" (multi-line with END terminator)
# Returns: Echoes collected content or empty string if none provided
collect_ai_output() {
    local prompt_message="$1"
    local mode="${2:-single}"  # Default to single-line mode
    
    print_info "$prompt_message"
    
    if [[ "$mode" == "multi" ]]; then
        # Multi-line input mode with END terminator
        print_info "Type 'END' on a new line when finished:"
        
        local content=""
        local line
        while IFS= read -r line; do
            if [[ "$line" == "END" ]]; then
                break
            fi
            content+="${line}"$'\n'
        done
        
        echo "$content"
    else
        # Single-line input mode
        local single_line_input
        read -r -p "$(echo -e "${YELLOW}Paste AI-generated content (or press Enter to skip): ${NC}")" single_line_input
        echo "$single_line_input"
    fi
}

# ==============================================================================
# CLEANUP AND RESOURCE MANAGEMENT
# ==============================================================================

# Cleanup handler for temporary files
# Registered via trap in main() to ensure cleanup on EXIT/INT/TERM
cleanup() {
    local exit_code=$?
    if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
        print_info "Cleaning up temporary files..."
        for temp_file in "${TEMP_FILES[@]}"; do
            [[ -f "$temp_file" ]] && rm -f "$temp_file"
        done
    fi
    exit $exit_code
}

# ==============================================================================
# WORKFLOW PROGRESS TRACKING
# ==============================================================================

# Update workflow status for a step
# Usage: update_workflow_status <step_name> <status>
update_workflow_status() {
    local step="$1"
    local status="$2"
    WORKFLOW_STATUS["$step"]="$status"
}

# Show overall workflow progress
show_progress() {
    local completed=0
    for status in "${WORKFLOW_STATUS[@]}"; do
        [[ "$status" == "✅" ]] && ((completed++))
    done
    
    echo -e "\n${CYAN}Progress: ${completed}/${TOTAL_STEPS} steps completed${NC}"
}

# Export all utility functions
export -f print_header print_success print_error print_warning print_info print_step
export -f save_step_issues save_step_summary
export -f confirm_action collect_ai_output cleanup
export -f update_workflow_status show_progress
